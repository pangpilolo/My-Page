# 短链接重点内容

## 海量用户注册

### 代码逻辑
1. 优先走布隆过滤器，查看对应的用户名是否存在
2. 使用tryLock去提前结束一部分相同用户名的用户注册
3. 将信息存储数据库
4. 在存入布隆过滤器中

进一步优化 分库分表
1. 同时要支持海量用户注册，那么就意味着用户量比较庞大，同时为了后续的查询，我们需要对用户表提前设计时就进行分库或者分表。
2. 这里采用分表的方式，同时是水平切分，主要切分数据量。
3. 为了保证极端的并发情况下，两个相同用户名注册。所以不能完全从业务层面验证是否唯一，对于数据库建立用户名唯一索引，同时采用用户名作为分表的分片键
  a. 相同的用户名分到相同的表，所以即使极端并发情况下，也能使用唯一索引保证用户注册失败。

分库分表的相关内容

## 用户信息保护(脱敏)
### 代码逻辑
1. 在互联网应用中，用户的信息需要被保护，你不清楚用户的设备使用时是否被监控
2. 类似身份证、手机号、年龄、性别等等都最好加密存储，同时前端获取数据时，也要进行脱敏
  a. 加密存储指的是在存到数据库中时，利用加密算法+加密key可以解密和加密信息，也就是当需要不加密信息时也可以解密出来使用
  b. 信息脱敏是指将信息的一部分不展示用*代替，例如购票网站中手机号一般现实前几位后后4位：135****4267，同时给前端返回脱敏信息时，一定要在后端屏蔽后发给前端，因为可能会被网络抓包等工具获取真实信息

## 短链接的创建

代码地址：`ShortLinkServiceImpl#createShortLink`

```java
public ShortLinkCreateRespDTO createShortLink(ShortLinkCreateReqDTO requestParam) {
    verificationWhitelist(requestParam.getOriginUrl());
    if (StrUtil.isBlank(requestParam.getOriginUrl())) {
        throw new ServiceException(ShortLinkErrorCodeEnum.ORIGIN_URL_NOT_BLANK);
    }
    if (StrUtil.isBlank(requestParam.getDomain())) {
        throw new ServiceException(ShortLinkErrorCodeEnum.DOMAIN_NOT_BLANK);
    }
    String shortLinkUri = generateShortLinkUri(shortLinkDefaultDomain, requestParam.getOriginUrl());
    ShortLinkDO saveDO = BeanCopyUtils.copyBean(requestParam, ShortLinkDO.class);
    saveDO.setFullShortUrl(shortLinkDefaultDomain + "/" + shortLinkUri);
    saveDO.setShortUri(shortLinkUri);
    // 设置默认启用状态为 启用→1
    saveDO.setEnableStatus(ServiceConstant.ENABLE_STATUS_OPEN);
    // 如果有效期类型，创建类型为空则默认值
    saveDO.setCreatedType(ObjUtil.isEmpty(saveDO.getCreatedType()) ? 0 : saveDO.getCreatedType());
    saveDO.setValidDateType(ObjUtil.isEmpty(saveDO.getValidDateType()) ? 0 : saveDO.getValidDateType());
    saveDO.setFavicon(getFavicon(requestParam.getOriginUrl()));
    LinkGotoDO linkGotoDO = new LinkGotoDO();
    linkGotoDO.setFullShortUrl(saveDO.getFullShortUrl());
    linkGotoDO.setGid(saveDO.getGid());
    try {
        save(saveDO);
        // 将路由入库
        linkGotoService.save(linkGotoDO);
    } catch (DuplicateKeyException e) {
        log.error("短链接:{},重复入库", saveDO.getFullShortUrl());
        throw new ServiceException(ShortLinkErrorCodeEnum.GENERATE_SO_MUCH);
    }
    shortLinkCreateCachePenetrationBloomFilter.add(saveDO.getFullShortUrl());
    // 新增是进行cache预热
    stringRedisTemplate.opsForValue().set(
            String.format(SHORT_LINK_GOTO_KEY_FORMAT, saveDO.getFullShortUrl()),
            saveDO.getOriginUrl(),
            LinkUtil.getLinkCacheValidTime(saveDO.getValidDate()),
            TimeUnit.MILLISECONDS
    );
    return ShortLinkCreateRespDTO.builder()
            .fullShortUrl("http://" + saveDO.getFullShortUrl())
            .group(new ShortLinkGroupRespDTO(saveDO.getGid(), null))
            .domain(shortLinkDefaultDomain)
            .originUrl(saveDO.getOriginUrl())
            .build();
}
```

### 代码逻辑
1. 根据原始链接生成62位的短链接字符串
  a. 在生成时就不断检查布隆过滤器，直到生成10次异常返回，或者生成成功返回短链接字符串
2. 组装短链接存储对象、短链接唯一索引表存储对象、路由存储对象
3. 存储到数据库中，一旦唯一索引表有唯一冲突后，进行事务回滚，同时为了解决Redis宕机丢失一部分数据后导致布隆过滤器判断错误，将当前短链接添加到布隆过滤器中，具体请看如果布隆过滤器挂了，里边存的数据全丢失了，怎么恢复呢？
4. 当所有存储完毕后，将短链接加入布隆过滤器
5. 预热短链接，将短链接缓存

## 修改短链接

代码地址：`ShortLinkServiceImpl#updateShortLink`
```java
public void updateShortLink(ShortLinkUpdateReqDTO requestParam) {
    verificationWhitelist(requestParam.getOriginUrl());
    // 根据原本的gid查询短链接
    LambdaQueryWrapper<ShortLinkDO> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(ShortLinkDO::getGid, requestParam.getOriginGid())
            .eq(ShortLinkDO::getFullShortUrl, requestParam.getFullShortUrl())
            .eq(ShortLinkDO::getDelFlag, ServiceConstant.NO_DELETE_FLAG)
            .eq(ShortLinkDO::getEnableStatus, ServiceConstant.ENABLE_STATUS_OPEN);
    ShortLinkDO queryLink = getOne(queryWrapper);
    if (ObjUtil.isEmpty(queryLink)) {
        throw new ClientException("短链接记录不存在");
    }
    // 根据是否改变分组来决定修改
    if (ObjUtil.equals(requestParam.getGid(), requestParam.getOriginGid())) {
        // 没有修改分组，则直接修改即可
        LambdaUpdateWrapper<ShortLinkDO> updateWrapper = new LambdaUpdateWrapper<>();
        updateWrapper.eq(ShortLinkDO::getGid, requestParam.getOriginGid())
                .eq(ShortLinkDO::getFullShortUrl, requestParam.getFullShortUrl())
                .eq(ShortLinkDO::getDelFlag, ServiceConstant.NO_DELETE_FLAG)
                .eq(ShortLinkDO::getEnableStatus, ServiceConstant.ENABLE_STATUS_OPEN)
                .set(StringUtil.isNotBlank(requestParam.getOriginUrl()), ShortLinkDO::getOriginUrl, requestParam.getOriginUrl())
                .set(ObjUtil.isNotEmpty(requestParam.getCreatedType()), ShortLinkDO::getCreatedType, requestParam.getCreatedType())
                .set(ShortLinkDO::getValidDateType, requestParam.getValidDateType())
                .set(ShortLinkDO::getDescribe, requestParam.getDescribe());
        if (ValidDateTypeEnum.PERMANENT.getType().equals(requestParam.getValidDateType())) {
            updateWrapper.set(ShortLinkDO::getValidDate, null);
        } else {
            updateWrapper.set(ShortLinkDO::getValidDate, requestParam.getValidDate());
        }
        update(updateWrapper);
    } else {
        // 通过上锁保证统计信息能正常统计到对应的表中
        RLock lock = redissonClient.getLock(String.format(RedisKeyConstant.LOCK_GID_UPDATE_KEY, requestParam.getFullShortUrl()));
        lock.lock();
        try {
            // 如果修改了分组先把原本的短链接删除
            remove(queryWrapper);
            ShortLinkDO save = ShortLinkDO.builder()
                    .domain(queryLink.getDomain())
                    .shortUri(queryLink.getShortUri())
                    .fullShortUrl(queryLink.getFullShortUrl())
                    .originUrl(requestParam.getOriginUrl())
                    .gid(requestParam.getGid())
                    .createdType(requestParam.getCreatedType())
                    .validDateType(requestParam.getValidDateType())
                    .validDate(requestParam.getValidDate())
                    .describe(requestParam.getDescribe())
                    .enableStatus(ServiceConstant.ENABLE_STATUS_OPEN)
                    .build();
            save.setDelFlag(ServiceConstant.NO_DELETE_FLAG);
            save(save);
            // 同时修改路由表,这里因为路由表分表了，所以需要删除再新增
            LambdaUpdateWrapper<LinkGotoDO> gotoQueryWrapper = new LambdaUpdateWrapper<>();
            gotoQueryWrapper.eq(LinkGotoDO::getFullShortUrl, queryLink.getFullShortUrl())
                    .set(LinkGotoDO::getGid, requestParam.getGid());
            linkGotoService.remove(gotoQueryWrapper);
            LambdaQueryWrapper<LinkGotoDO> linkGotoQueryWrapper = Wrappers.lambdaQuery(LinkGotoDO.class)
                    .eq(LinkGotoDO::getFullShortUrl, requestParam.getFullShortUrl())
                    .eq(LinkGotoDO::getGid, queryLink.getGid());
            LinkGotoDO shortLinkGotoDO = linkGotoService.getOne(linkGotoQueryWrapper);
            linkGotoService.remove(linkGotoQueryWrapper);
            shortLinkGotoDO.setGid(requestParam.getGid());
            linkGotoService.save(shortLinkGotoDO);
        } finally {
            lock.unlock();
        }
        // 如果修改了过期类型和过期时间就删除goto缓存，避免缓存不失效
        if (!Objects.equals(queryLink.getValidDate(), requestParam.getValidDate())
        || !Objects.equals(queryLink.getValidDateType(), requestParam.getValidDateType())
                || !Objects.equals(queryLink.getOriginUrl(), requestParam.getOriginUrl())) {
            stringRedisTemplate.delete(String.format(SHORT_LINK_GOTO_KEY_FORMAT, queryLink.getFullShortUrl()));
            // 因为如果修改了过期时间可能就存在原本在库中的短链接是过期的，被放置了isNull的缓存
            // 所以如果现在永久有效 或者 当前设置过期的时间还没有过期那么就删除 isNull缓存
            Date currentDate = new Date();
            if (queryLink.getValidDate() != null && queryLink.getValidDate().before(currentDate)) {
                if (Objects.equals(requestParam.getValidDateType(), ValidDateTypeEnum.PERMANENT.getType()) || requestParam.getValidDate().after(currentDate)) {
                    stringRedisTemplate.delete(String.format(SHORT_LINT_GOTO_IS_NULL_KEY_FORMAT, requestParam.getFullShortUrl()));
                }
            }
        }
    }
}
```

### 代码逻辑
1. 根据修改参数查询出原本在数据库中的短链接
2. 对比是否修改分组id，因为分组id涉及短链接的分表
3. 如果修改分组id则上锁，删除原本的短链接在数据库的记录，将修改分组id后的数据插入数据库，修改路由表中短链接对应的分组id信息
  a. 这里上锁是因为避免并发情况下，短链接表中的当日访问量是根据分组id和短链接定位的，所以一旦不上锁，拿到的分组id是旧的，就会导致update语句执行失败
4. 不修改分组id，则直接更新数据到数据库
5. 判断是否修改了是否过期标志和过期时间，删除对应的isNull缓存，和原始链接缓存
  a. 如果设置为不过期或者新的过期时间比现在晚，那么就需要删除isNull缓存
  b. 如果设置为过期，且过期时间已经到了，则删除goto缓存

## 短链接跳转

代码地址：`ShortLinkServiceImpl#restoreUrl`
```java
public void restoreUrl(String shortUrl, HttpServletRequest request, HttpServletResponse response) {
    // 根据配置的域名去根据端口号修改逻辑
    String portStr = Optional.of(request.getServerPort())
            .filter(item -> !Objects.equals(item, 80))
            .map(String::valueOf)
            .map(item -> ":" + item)
            .orElse("");
    // 获取域名，组合完整短链接
    String fullShortUrl = request.getServerName() + portStr + "/" + shortUrl;
    // 判断是否在布隆过滤器中，因为如果布隆过滤器中说没有那么就是一定没有
    if (!shortLinkCreateCachePenetrationBloomFilter.contains(fullShortUrl)) {
        responseSendRedirectToNotFound(response);
        return;
    }
    String originalUrl = stringRedisTemplate.opsForValue().get(String.format(SHORT_LINK_GOTO_KEY_FORMAT, fullShortUrl));
    if (StrUtil.isNotBlank(originalUrl)) {
        responseSendRedirectToOriginal(response, request, originalUrl, fullShortUrl);
        return;
    }
    // 特殊情况，穿布隆过滤器的情况
    String isNullUrl = stringRedisTemplate.opsForValue().get(String.format(SHORT_LINT_GOTO_IS_NULL_KEY_FORMAT, fullShortUrl));
    if (StrUtil.isNotBlank(isNullUrl)) {
        responseSendRedirectToNotFound(response);
        return;
    }
    // 如果缓存中拿不到，则双重检查锁进行查库
    RLock lock = redissonClient.getLock(String.format(SHORT_LINK_GOTO_LOCK_KEY_FORMAT, fullShortUrl));
    lock.lock();
    try {
        originalUrl = stringRedisTemplate.opsForValue().get(String.format(SHORT_LINK_GOTO_KEY_FORMAT, fullShortUrl));
        if (StrUtil.isNotBlank(originalUrl)) {
            responseSendRedirectToOriginal(response, request, originalUrl, fullShortUrl);
            return;
        }
        // 特殊情况，穿布隆过滤器的情况
        isNullUrl = stringRedisTemplate.opsForValue().get(String.format(SHORT_LINT_GOTO_IS_NULL_KEY_FORMAT, fullShortUrl));
        if (StrUtil.isNotBlank(isNullUrl)) {
            // 重定向到不存在页面
            responseSendRedirectToNotFound(response);
            return;
        }
        // 路由表获取短链接的gid
        LambdaQueryWrapper<LinkGotoDO> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(LinkGotoDO::getFullShortUrl, fullShortUrl);
        LinkGotoDO gotoDO = linkGotoService.getOne(queryWrapper);
        // 如果不存在直接返回异常，说明布隆过滤器误判了
        if (ObjUtil.isEmpty(gotoDO)) {
            // 将空值放入redis中避免穿透,设置3分钟的过期时间
            stringRedisTemplate.opsForValue().set(String.format(SHORT_LINT_GOTO_IS_NULL_KEY_FORMAT, fullShortUrl), "-", 3, TimeUnit.MINUTES);
            responseSendRedirectToNotFound(response);
            // 选择直接return是因为懒得浪费性能去处理异常了
            return;
        }
        // 根据gid获取对应的原始链接
        LambdaQueryWrapper<ShortLinkDO> linkQueryWrapper = new LambdaQueryWrapper<>();
        linkQueryWrapper.eq(ShortLinkDO::getGid, gotoDO.getGid())
                .eq(ShortLinkDO::getFullShortUrl, gotoDO.getFullShortUrl())
                .eq(ShortLinkDO::getDelFlag, ServiceConstant.NO_DELETE_FLAG)
                .eq(ShortLinkDO::getEnableStatus, ServiceConstant.ENABLE_STATUS_OPEN);
        ShortLinkDO shortLinkDO = getOne(linkQueryWrapper);
        if (ObjUtil.isNotEmpty(shortLinkDO)) {
            // 检查有效期是否过期
            if (ObjUtil.isNotEmpty(shortLinkDO.getValidDate()) && shortLinkDO.getValidDate().before(new Date())) {
                // 如果这是一个已经过期的短链接，则添加为空缓存
                stringRedisTemplate.opsForValue().set(String.format(SHORT_LINT_GOTO_IS_NULL_KEY_FORMAT, fullShortUrl), "-", 3, TimeUnit.MINUTES);
                responseSendRedirectToNotFound(response);
                return;
            }
            originalUrl = shortLinkDO.getOriginUrl();
            //                stringRedisTemplate.opsForValue().set(String.format(SHORT_LINK_GOTO_KEY_FORMAT, fullShortUrl), originalUrl);
            // 根据有效时间进行缓存
            stringRedisTemplate.opsForValue().set(
                    String.format(SHORT_LINK_GOTO_KEY_FORMAT, shortLinkDO.getFullShortUrl()),
                    shortLinkDO.getOriginUrl(),
                    LinkUtil.getLinkCacheValidTime(shortLinkDO.getValidDate()),
                    TimeUnit.MILLISECONDS
            );
            responseSendRedirectToOriginal(response, request, originalUrl, fullShortUrl);
        } else {
            // 这个短链接可能在短链接表中删除，但是路由表没有更新，数据异常导致的
            stringRedisTemplate.opsForValue().set(String.format(SHORT_LINT_GOTO_IS_NULL_KEY_FORMAT, fullShortUrl), "-", 3, TimeUnit.MINUTES);
            responseSendRedirectToNotFound(response);
        }
    } finally {
        lock.unlock();
    }
}
```

### 代码逻辑
1. 通过pathVarible获取路径参数中的短链接如http://pangpi.link/ax1Adf，可以通过路径参数拿到ax1Adf
2. 如果配置文件中配置了域名，那么使用配置的域名和短链接参数组成完整短链接
3. 判断是否在布隆过滤器中，如果不在则直接返回404页面不存在
4. 如果布隆过滤器中判断存在，则查询短链接映射原始链接的缓存key-value
  a. 查询出有结果则进行302重定向
5. 没有查出，可能是原始链接缓存过期，也有可能是错误链接穿过了布隆过滤器
6. 查询空值缓存，如果查出有值则返回404页面不存在
7. 没有查询出空值缓存也有两种情况，空值缓存过期和原始链接缓存过期
8. 进行分布式锁，锁的是当前短链接，上锁后检查原始链接缓存和空值缓存和上面逻辑一样，这是因为上了分布式锁后，被上锁的线程被唤醒后不查缓存而直接查数据库，那么这个锁就是没有意义的。
  a. 这里上锁的目的就是方式高并发情况下，大量线程同时查库
  b. 同时也可以把分布式锁修改为本地锁，可以降低一部分系统压力
9. 查询路由表，查询出当前短链接的分组id
  a. 如果没有查出，说明此短链接要么不存在，要么就是被删除了(路由表中设置了逻辑删除)，所以设置其空值缓存到Redis
10. 查询出分组id后，去短链接表查询具体短链接记录
  a. 如果为空，则添加空值缓存
11. 不为空则检查是否短链接有效时间是否过期，过期则添加空值缓存
12. 不为空且没有过期，进行设置原始链接缓存并重定向跳转

上述的空值缓存和分布式锁以及原始链接缓存都是在预防，缓存击穿和缓存穿透等问题

# 短链接监控

代码地址：`ShortLinkServiceImpl#shortLinkStats`

```java
Map<String, String> producerMap = new HashMap<>();
producerMap.put("statsRecord", JSON.toJSONString(statsRecord));
// 消息队列为什么选用RocketMQ？详情查看：https://nageoffer.com/shortlink/question
shortLinkStatsSaveProducer.sendMessage(producerMap);
```

### 代码逻辑

这里监控统计是通过消息队列消费消息来完成的，因为监控涉及非常多的表插入，且都是在成功重定向后才会进行统计，所以如果不使用消息队列或者异步的方式就只有在跳转短链接的业务逻辑中进行同步调用
1. 在短链接跳转前统计当前的信息，通过cookie来判断是否是第一次访问，根据ip获取地区，通过request获取操作系统，浏览器等等信息封装为一个监控数据对象，进行json化，放入消息队列中
2. 拿到消息后获取消息id配合Redis检查幂等性
  a. 检查是否消费过此消息(注意是消费过而不是消费成功)
    ⅰ. 如果消费过则检查是否消费成功，消费成功则return，出现了消息重复消费问题
    ⅱ. 如果没成功则报错退出，因为此消息此时可能正在被消费，报错这条消息会被放入消息队列等待重复消费，等到再次消费时要么消费成功，要么继续报异常退出，要么此消息消费失败后幂等标志从redis中过期重新消费
  b. json反序列化获取监控数据对象，调用消费消息逻辑
3. 从监控数据对象中获取当前短链接的锁，这里和之前提到的修改短链接中的逻辑保持一致，避免统计出错
4. 获取到锁后，查询路由表或者分组id
5. 根据封装好的监控数据分表放入不同的监控表中
6. 释放锁，同时return
7. 此时消息消费完毕后，则删除消息队列中的消息，并且设置消费幂等标志为消费成功
8. 如果在消费的时候出现消费失败，那么就会设置幂等标志为消费失败